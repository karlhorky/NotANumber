---
title: 'How Does a Compiler Work?'
blurb: 'Introducing the compiler pipeline.'
publishedAt: '2021-12-21'
editedAt: '2021-12-21'
---

import Figure, { Caption } from '@/elements/Figure'
import BabelPipeline from '@/components/debugger/BabelPipeline'
import TreeSandbox from '@/components/debugger/TreeSandbox'

> This is part 1 in a series of posts on rebuilding a Babel-like compiler from first principles. For a complete lists of posts, see the [main page](.).

Before we get into the details of building a compiler, let's take a second to go over how a compiler works from a bird's eye view.

A compiler, in a nutshell, is a piece of software that converts code from one language to another, typically lower-level, language. In the front-end web world, compilers are more commonly known as _transpilers_ because the input and the output is typically language of the same level - either JavaScript to JavaScript, or TypeScript to JavaScript. [Babel](https://babeljs.io/) is one such transpiler.

## The Compiler Pipeline

I like to think of a compiler as a pipeline with four distinct phases:

1. Tokenization;
2. Parsing;
3. Transformation;
4. Generation.

Each step of the pipeline takes the output of the _previous_ step as its _input_. For example, the parsing phase takes in a list of tokens generated in the tokenization phase, and the transforming phase takes in the syntax tree generated in the parsing phase.

The code for a compiler then, is nothing more than this:

```ts
function compile(inputCode) {
  const tokens = tokenize(inputCode)
  const tree = parse(tokens)
  const transformedTree = transform(tree)
  return generate(transformedTree)
}
```

So what do each of these phases take as input, and what do they output?

## Tokenization

The first phase, the **tokenization** phase, takes in your code as a string and splits it up into "words" called tokens. Each token represents the smallest sequence of characters that has meaning in the language. For example, the JS code `const a = 10` can be broken down into the following "words" or tokens:

```
[const] [a] [=] [10]
```

We'll talk more about tokens and the tokenizer in [[Tokenizer]].

## Parsing

The second phase, **parsing**, takes this list of tokens and converts it into a tree-like structure called an **abstract syntax tree**, or AST for short. If you read my [debugger](../debugger) post, you might know about these trees already.

An abstract syntax tree essentially adds _context_ to the tokens and provides more meaning to them. For example, the tree for `const a = 10` looks something like this:

<TreeSandbox initialCode={`const a = 10`} depth={Infinity} hideDetailView />

Try changing the code in the editor to see what trees for other JavaScript code might look like!

The parser, the piece of the compiler in charge of this phase, is arguably the most interesting part of the compiler. We'll talk about it more in [[Parsing console.log]].

## Transformation

The third phase, **transformation**, takes in the syntax tree generated by the parser and transforms it to a different syntax tree. In a traditional compiler, this phase would convert the tree into a tree that corresponds to the output programming language. But in a transpiler like Babel, this phase is where **plugins** come into play.

Each plugin takes a tree and transforms it in some way - for example to strip out types from a TypeScript file, make modern JS executable in Internet Explorer, or even [power a debugger](../debugger). This phase is what makes Babel as powerful as it is.

<Figure size="xl">
  <BabelPipeline />
  <Caption>The Babel Pipeline</Caption>
</Figure>

## Generation

The last phase, **generation**, takes in the transformed syntax tree and outputs executable code. In a traditional compiler, this might be machine language or bytecode. But for Babel, the output code is JavaScript. In some ways, the generation phase is the _inverse_ of the tokenization and parsing phases - albeit generating code is (surprisingly) a lot simpler than parsing it.

```
some generation visual
```

We'll talk more about transformations and code generation in [[Vexing Visitors]].

And that's a high level overview of how Babel works! In the next few posts, we're going to use these principles to build a compiler that can understand and transform a simple hello world function:

```js
function hello(message) {
  console.log(message)
}
```

We'll see you there!
