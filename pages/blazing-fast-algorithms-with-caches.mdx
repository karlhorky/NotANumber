---
title: 'Blazing Fast Algorithms With Caches'
blurb: "A JavaScript solution to advent of code's day 6 problem."
description: 'How introducing a cache made my algorithm over 10,000x faster.'
publishedAt: '2022-01-08'
editedAt: '2022-01-08'
---

import Figure from '@/elements/Figure'
import Callout from '@/elements/Callout'
import { Intuitive } from '@/components/blazing-fast-algorithms-with-caches/Intuitive'
import { FormulaStartSlider } from '@/components/blazing-fast-algorithms-with-caches/FormulaStartSlider'

I've been slowly going through the [advent of code challenges](https://adventofcode.com/) to practice my algorithm skills when I ran into a performance bottleneck in my solution to day 6.

After a bit of head scratching I landed on a solution that I was pretty happy with, and in this post, we'll go over the solution in its entirety. In particular, I talk about how I sped up an algorithm that was taking _over 25 seconds_ to taking only _0.07 seconds_ in the end.

Let's take a deeper look, shall we?

## The Problem

In day 6 of advent of code we have to implement an algorithm that models the growth of a school of fishes. Each fish creates a new fish every 7 days, and is represented as a single number - the number of days until it creates a new fish.

For example, the following array represents a school of three fishes:

```
3,1,2
```

Where the first fish will create a new fish in three days, the second fish in 1 day, and the third fish in 2 days. Note that a fish can have a value of zero - this means that the fish will create the fish today, and the school will include the new fish in the _next day_.

Each passing day reduces each fish's value by 1. When a fish reaches zero, a new fish will be added to the school and the fish will reset back to the start of the cycle.

Using the same example as before, after 3 days the school will look like this:

```
day 0 -> 3,1,2
day 1 -> 2,0,1
day 2 -> 1,6,0,8 <-- new fish created by fish #2
day 3 -> 0,5,6,7,8 <-- new fish created by fish #3
```

New fish needs an extra two days before it can start making fish, so they start with a value of eight instead of six. Once they've created their first fish, their next fish will take the regular seven days.

In this example, our algorithm should return "5" because after 3 days, the school consists of five fish.

## The Intuitive Way

The most intuitive way to solve this algorithm is to simulate each passing day, where we:

1. Iterate through every day until we hit the desired number of days;
2. For each day and for each fish, if the fish count is zero, add a new fish to the school with a starting value of eight and reset the fish's value to six; otherwise, reduce the fish's value by one.
3. After iterating through all the days, return the size of the school.

<Figure size="lg">
  <Intuitive />
</Figure>

This method is simple, straightforward, and works great! More than enough to get through the 80 day requirement of part A of the challenge.

## It's a Bit... Slow

In part B of the challenge, the question asked for the total size of the school after **256 days** have passed. "It's only three times as many days", I thought - the same algorithm should work, right?

Unfortunately... not quite. I increased the number of days to 256 and let it run for a bit. After about 18 seconds, the program crashed with the following V8 error (V8 is the JavaScript engine that Node is built on top of): `FATAL ERROR: invalid array length Allocation failed - JavaScript heap out of memory`.

Interesting! The number of fish grew so much that there's no longer enough space to keep every single fish in memory. 18 seconds feels like a long time too, so it looks like not only do we have a memory problem, we also have a performance problem.

Back to the drawing board we go.

<Callout label="How much space DO we need?">

I got curious - assuming the JS heap is infinitely large, how much space do we need to store all the fish? Thankfully, the question is kind enough to provide us the expected answer for the example input, so we can figure it out with a bit of math.

With a starting school size of **five fish**, after **256 days**, there will be 26,984,457,539 fish in the school - almost 27 billion! If each fish is represented as a number, and each [number takes up eight bytes of memory](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number), then we will need almost 216 **gigabytes** of memory to store all the fish!

</Callout>

### A Smarter Solution

I was staring at the code for a while trying to think of ways to optimize it, and I figured there's two things we can change:

1. Remove the array altogether. The question asked for the _number_ of fish, not the values of them, so it would be wasteful to store the array.
2. Removing the outer `days` loop. Is there a way for us to _infer_ the final value without having to loop through every single day?

I was imagining an algorithm that looks like this:

```js
const getSchoolSize = (fishes, days) => {
  let total = 0

  fishes.forEach((fish) => {
    total += getTotalFishAfterDays(fish, days)
  })

  return total
}
```

## Math-ing the Final Value

Let's take a step back. The question asked for the **total size of the school** after a certain number of days have passed. One place to start would be to count how many fish _one_ fish is responsible for, and then go from there.

### Finding the Number of Created Fish

With that in mind, how do we get rid of the outer `days` loop? Given a fish, is there a way for us to calculate how many fish it creates without using a loop?

Let's say we start with a fish of value six. After 14 days, the school will look like this:

```
day 0  -> 6
day 1  -> 5
day 2  -> 4
day 3  -> 3
day 4  -> 2
day 5  -> 1
day 6  -> 0
day 7  -> 6, 8
day 8  -> 5, 7
day 9  -> 4, 6
day 10 -> 3, 5
day 11 -> 2, 4
day 12 -> 1, 3
day 13 -> 0, 2
day 14 -> 6, 1, 8
```

Do you see a pattern?

Here's a hint:

```txt highlight=0,7,14
day 0  -> 6
day 1  -> 5
day 2  -> 4
day 3  -> 3
day 4  -> 2
day 5  -> 1
day 6  -> 0
day 7  -> 6, 8
day 8  -> 5, 7
day 9  -> 4, 6
day 10 -> 3, 5
day 11 -> 2, 4
day 12 -> 1, 3
day 13 -> 0, 2
day 14 -> 6, 1, 8
```

A new fish is created every seven days! So does that mean all we need to do is divide the number of days by seven to get the number of fish created?

```
no. of fish = no. of days / 7
```

Let's test it out. Using the above example, we have the number of days as 14, so the formula gives us `14 / 7 = 2` fish created. That looks correct!

But what if we change the fish's starting value?

<FormulaStartSlider />

It looks like changing the starting value has the same effect as "shifting up" the cycle, so the first cycle happens earlier for smaller starting values. While the number of days here isn't big enough for a new fish to be created, you can probably imagine how shifting the cycle to run earlier might mean one or two more fishes in the long term.

So our formula needs to be changed to take the starting value into account. But how exactly? One way is to subtract the starting value from the total number of days:

```
no. of fish = (days - start) / 7
```

This has the effect of using the number of days from the _first cycle_, rather than from the very beginning. If we test this out, we can see that it kinda has the number we're looking for:

```
no. of fish = (14 - 6) / 7 = 8 / 7 = 1.14 fishes
```

All we need to do is round it up to the next integer to get the correct number of fish - `Math.ceil(1.14) -> 2` fishes. This gives us the final formula for calculating how many fish is made:

```
no. of fish = Math.ceil((days - start) / 7)
```

### Getting the Fishes' Fishes

Cool! Given a fish and a number of days, we're able to calculate how many fish it creates over the period of time without using a loop. But we don't have the full picture yet.

If we take a look at the visual from before, notice that if we start with a value of three, a total of _three_ fish is created over 14 days, not two:

<FormulaStartSlider start={3} />

That's because the fish we created in day 4 created a new fish in day 13:

```txt highlight=4,13
day 0  -> 3
day 1  -> 2
day 2  -> 1
day 3  -> 0
day 4  -> 6, 8
day 5  -> 5, 7
day 6  -> 4, 6
day 7  -> 3, 5
day 8  -> 2, 4
day 9  -> 1, 3
day 10 -> 0, 2
day 11 -> 6, 1, 8
day 12 -> 5, 0, 7
day 13 -> 4, 6, 6, 8
day 14 -> 3, 5, 5, 7
```

So it's not enough to count how many fish the _original_ fish created; we also need to consider the fish created by all our child fishes too, and also their child fishes, and their child fishes, and so on.

Thankfully, we already have the formula for determining the number of fish created after a certain number of days, so we can reuse that same formula for all the fish that we created.

So now our algorithm looks like this:

```js
const getTotalFishAfterDays = (start, days) => {
  const directFishes = Math.ceil(days - start / 7)

  let subFishes = 0
  /* for every fish we create, add up the total fish they create */
  for (let fish = 0; fish < directFishes; fish++) {
    subFishes += getTotalFishAfterDays(8, /* num of days */ ???)
  }

  return 1 + subFishes
}
```

But what should we use as the number of days? We can't use the total number of days because the fish didn't exist at the start. Instead, we need to use the number of days from the day the fish was created:

```js highlight=6,7
const getTotalFishAfterDays = (start, days) => {
  const directFishes = Math.ceil(days - start / 7)

  let subFishes = 0
  /* for every fish we create, add up the total fish they create */
  for (let cycleNumber = 0; cycleNumber < directFishes; cycleNumber++) {
    const birthday = ???
    subFishes += getTotalFishAfterDays(8, days - birthday)
  }

  return 1 + subFishes
}
```

### Getting a Fish's Birthday

All that's left is to figure out when a fish was created.

Fish are created in a seven day cycle which means each fish will be created seven days after the previous fish.

```txt highlight=4,11
day 0  -> 3
day 1  -> 2
day 2  -> 1
day 3  -> 0
day 4  -> 6, 8
day 5  -> 5, 7
day 6  -> 4, 6
day 7  -> 3, 5
day 8  -> 2, 4
day 9  -> 1, 3
day 10 -> 0, 2
day 11 -> 6, 1, 8
day 12 -> 5, 0, 7
day 13 -> 4, 6, 6, 8
day 14 -> 3, 5, 5, 7
```

The _first_ fish is a special case - it's created once the starting value runs out, which happens after `start + 1` days have passed. This gives us the following formula to get a fish's birthday:

```
birthday = start + 1 + (7 * cycleNumber)
```

Where the cycle number ranges from 0 to however many cycles there are (which, equivalently, is also the number of fish that was created).

## putting it together

ok, cool! now that we know the birthday of any given fish, we can get the _relative_ number of days till the end by subtracting the total number of days with the birthday:

```js
const birthday = start + 1 + 7 * cycleNumber
subFishes += getTotalFish(8, days - birthday)
```

once we have the counts of all the fishes, we return that count + 1 (the fish that we started with):

```js
const getTotalFishes = (start, days) => {
  const cycles = Math.max(Math.ceil(days - start / 7), 0)

  let subFishes = 0
  for (let cycleNumber = 0; cycleNumber < cycles; cycleNumber++) {
    const birthday = start + 1 + 7 * cycleNumber
    subFishes += getTotalFish(8, days - birthday)
  }

  return 1 + subFishes
}
```

we don't include cycles in the final count to prevent double counting - the recursive `getTotalFishes` call will already include the fish that we created in its total.

## performance testing

great! let's give this a shot and see how it fares compared to our other implementation.

first let's hook it up to the original function:

```jsx
const DAYS = 256

export default (...fishes) => {
  let total = 0

  fishes.forEach((start) => {
    total += getTotalFishes(start, DAYS)
  })

  return total
}
```

remember that the original implementation ran for 18s before crashing because it ran out of memory. how does this one perform in comparison?

uh, it didn't run out of memory at least?

## iteration counter

let's tone down the number of days a little bit and add some logs to see what's going on.

for my part a solution, i added an iterations counter and incremented it for each iteration of the loop to see how many iterations we need to get the final answer:

```js
export default (...fishes) => {
  let iterations = 0

  for (let i = 0; i < DAYS; i++) {
    for (const [index, fish] of fishes.entries()) {
      iterations++
      if (!fish) {
        fishes[index] = NEW_FISH_TIME
        fishes.push(NEW_FISH_TIME + NEW_FISH_DELAY + 1)
      } else {
        fishes[index]--
      }
    }
  }

  console.log({ iterations })

  return fishes.length
}
```

- running it against the example input (which starts with 5 fishes), the algorithm needed 70k iterations to complete.
- running it against the provided input (which starts with 300 fishes), the algorithm needed over 4.4 million (!) iterations.
- running both algorithms took about 0.13s.

i added something similar for part b where i increment a counter for every call to `getTotalFishes`. the results were pretty surprising:

- the example input with **5 fishes** needed 5934 recursive calls
- the provided input with **300 fishes** needed over 385k recursive calls
- both inputs took a combined 0.10s to complete.

an order of magnitude better than the initial input, but still not quite fast enough it seems!

let's bump up the number of days to 100 days:

- part a needed 25 million iterations, ~0.32s to complete
- part b needed 2.17 million calls, ~0.2s to complete

and again to 120 days:

- part a -> 145 million iterations, 1.36s
- part b -> 12 million iterations, 0.84s

so the part b solution is about an order of magnitude faster than part a, but it's still not fast enough to solve 256 days in a decent amount of time.

how can we make it better?

## adding a cache

one thing i noticed is that we're doing repetitive work when moving from one fish to the next. for example, let's say we start with the following fishes and we want to calculate the total number of fishes after 10 days:

```
3,1,3
```

using our algorithm, we calculate the total number of fish created by the first fish 3, then the second fish 1, and the third fish 3.

however, the result of the first fish and the last fish is going to be the same because the number of days is the same and the starting value is the same as well, i.e. for both of those fishes we call this function:

```js
totalFishes += getTotalFishes(3, 10)
```

when we're calling the function a second time, we're _repeating_ the work of calling the function the first time. we can potentially save this inefficiency by storing the result of the previous calculation, and referring to that result instead, a process called **memoization**.

the general idea is this:

1. we add an object that's going to act as a "cache" - this object will contain key-value pairs where the key is a combination of the starting fish value and number of days, and the value is the total fish created after those number of days have passed.
2. before we start the calculation, we first check if the cache contains the combination of fish value and number of days; if it does, we return it. otherwise, we continue on with the calculation.
3. once we've calculated the total number of fish, we add the fish value-number of days combination to the cache.

in code, that looks something like this:

```js
const DAYS = 120

const cache = {}

export default (...fishes) => {
  let fishCount = 0

  fishes.forEach((start) => {
    fishCount += getTotalFishes(start, DAYS)
  })

  return fishCount
}

const getTotalFishes = (start, days) => {
  const key = `${start}-${days}`

  /**
   * Look in the cache to see if we've calculated this
   * specific combination of start and days.
   */
  if (cache[key]) {
    return cache[key]
  }

  const fishesCreated = Math.max(Math.ceil((days - start) / 7), 0)

  let subFishes = 0

  for (let offset = 0; offset < fishesCreated; offset++) {
    const birthday = start + 1 + 7 * offset
    subFishes += getTotalFishes(8, days - birthday)
  }

  const fishes = 1 + subFishes
  // add our result to the cache so future calls can refer to it
  cache[key] = fishes

  return fishes
}
```

let's try it out. how much better is this approach?

on the left is the command _without_ the cache, and on the right _with_ the cache, both calculating 120 days:

// gif showing side by side comparison

whoa! 0.84s down to 0.07s.

what if we bump it up to 140 days? or even higher?

// slider to change number of days

it'll take too long to show here, but the original approach took about 25 seconds to calculate 160 days whereas the cached approach took 0.07s - basically the same amount of time as before.

// graph with the time

as we keep adding days, the time it takes for the uncached approach explodes until it times out - but the cached approach takes almost the same amount of time every time, regardless of how many days there are. you can't even see the line in the graph above!

i bumped up the number of days to an absurd number like 1000 days and the cached approach took only _0.01s longer to complete_. my computer would light on fire if i tried running 1000 days on the original, uncached approach.

## analysis

so what gives? how come adding a cache makes the algorithm that much faster? to look into this, i added some more counters to count the number of times that a cache _hit_ and a cache _miss_ occurs.

- a cache hit is when the cache contains the arguments we're looking for, so we can skip the computation
- a cache miss is when the cache _doesn't_ contain the arguments we're looking for, so we need to manually perform the computation

```jsx
const DAYS = 120

const cache = {}
let hits = 0
let misses = 0

export default (...fishes) => {
  let fishCount = 0

  fishes.forEach((start) => {
    fishCount += getTotalFishes(start, DAYS)
  })

  console.log({ hits, misses })

  return fishCount
}

const getTotalFishes = (start, days) => {
  const key = `${start}-${days}`

  /**
   * Look in the cache to see if we've calculated this
   * specific combination of start and days.
   */
  if (cache[key]) {
    hits++
    return cache[key]
  }

  misses++

  const fishesCreated = Math.max(Math.ceil((days - start) / 7), 0)

  let subFishes = 0

  for (let offset = 0; offset < fishesCreated; offset++) {
    const birthday = start + 1 + 7 * offset
    subFishes += getTotalFishes(8, days - birthday)
  }

  const fishes = 1 + subFishes
  cache[key] = fishes

  return fishes
}
```

without the cache, computing 120 days took about ~12 million calls to `getTotalFishes`. what about with the cache?

```
$ yarn test 6b
  { hits: 1158, misses: 122 }
  Result: 11967638
  Done in 0.07s.
```

adding up the number of hits and misses gives us the total number of calls to be 1280 calls - about 10,000x less calls than without the cache! this means that >99% of the calls were part of repeated work that we got rid of using the cache.

out of those 1280 calls, 1158 were cache hits, meaning 90.4% of the time, the cache contained the answer we were looking for. this also means that we only needed to run 10% of the calls to get the answer for 100% of the input.

in a larger number of days, the effect is even more pronounced. with 1200 days, 101k out of 102k total calls were cache hits - 99% of the calculations were repeats!

## summary

here's my solution to advent of code's day 6 problem in its entirety, without the performance measuring code:

```js
const DAYS = 256

const cache = {}

export default (...fishes) => {
  let fishCount = 0

  fishes.forEach((start) => {
    fishCount += getTotalFishes(start, DAYS)
  })

  return fishCount
}

const getTotalFishes = (start, days) => {
  const key = `${start}-${days}`

  /**
   * Look in the cache to see if we've calculated this
   * specific combination of start and days.
   */
  if (cache[key]) {
    return cache[key]
  }

  const fishesCreated = Math.max(Math.ceil((days - start) / 7), 0)

  let subFishes = 0

  for (let offset = 0; offset < fishesCreated; offset++) {
    const birthday = start + 1 + 7 * offset
    subFishes += getTotalFishes(8, days - birthday)
  }

  const fishes = 1 + subFishes
  cache[key] = fishes

  return fishes
}
```

i'm pretty proud of this one because i'm not quite good with algorithms, and i figured this out all on my own! i admit, when i added the cache, i didn't think it would improve the solution by as much as it did, but i'm glad it worked out.

i came across a few other clever solutions out there (like one involving rotating arrays) that i'm not quite clever enough to decipher, but this approach was the one that made the most sense to me. maybe i'll amend this post in the future with those solutions when (or if) i figure it out.

until next time, thanks for reading!
