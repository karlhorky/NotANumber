---
title: 'Blazing Fast Algorithms With Caches'
blurb: "A JavaScript solution to advent of code's day 6 problem."
description: 'How introducing a cache made my algorithm over 10,000x faster.'
publishedAt: '2022-01-08'
editedAt: '2022-01-08'
---

import Figure from '@/elements/Figure'
import Callout from '@/elements/Callout'
import { Intuitive } from '@/components/blazing-fast-algorithms-with-caches/Intuitive'

I've been slowly going through the [advent of code challenges](https://adventofcode.com/) to practice my algorithm skills when I ran into a performance bottleneck in my solution to day 6.

After a bit of head scratching I landed on a solution that I was pretty happy with, and in this post, we'll go over the solution in its entirety. In particular, I talk about how I sped up an algorithm that was taking _over 25 seconds_ to taking only _0.07 seconds_ in the end.

Let's take a deeper look, shall we?

## The Problem

In day 6 of advent of code we have to implement an algorithm that models the growth of a school of fishes. Each fish creates a new fish every 7 days, and is represented as a single number - the number of days until it creates a new fish.

For example, the following array represents a school of three fishes:

```
3,1,2
```

Where the first fish will create a new fish in three days, the second fish in 1 day, and the third fish in 2 days. Note that a fish can have a value of zero - this means that the fish will create the fish today, and the school will include the new fish in the _next day_.

Each passing day reduces each fish's value by 1. When a fish reaches zero, a new fish will be added to the school and the fish will reset back to the start of the cycle.

Using the same example as before, after 3 days the school will look like this:

```
day 0 -> 3,1,2
day 1 -> 2,0,1
day 2 -> 1,6,0,8 <-- new fish created by fish #2
day 3 -> 0,5,6,7,8 <-- new fish created by fish #3
```

New fish needs an extra two days before it can start making fish, so they start with a value of eight instead of six. Once they've created their first fish, their next fish will take the regular seven days.

In this example, our algorithm should return "5" because after 3 days, the school consists of five fish.

## The Intuitive Way

The most intuitive way to solve this algorithm is to simulate each passing day, where we:

1. Iterate through every day until we hit the desired number of days;
2. For each day and for each fish, if the fish count is zero, add a new fish to the school with a starting value of eight and reset the fish's value to six; otherwise, reduce the fish's value by one.
3. After iterating through all the days, return the size of the school.

<Figure size="lg">
  <Intuitive />
</Figure>

This method is simple, straightforward, and works great! More than enough to get through the 80 day requirement of part A of the challenge.

## It's a Bit... Slow

In part B of the challenge, the question asked for the total size of the school after **256 days** have passed. "It's only three times as many days", I thought - the same algorithm should work, right?

Unfortunately... not quite. I increased the number of days to 256 and let it run for a bit. After about 18 seconds, the program crashed with the following V8 error (V8 is the JavaScript engine that Node is built on top of): `FATAL ERROR: invalid array length Allocation failed - JavaScript heap out of memory`.

Interesting! The number of fish grew so much that there's no longer enough space to keep every single fish in memory. 18 seconds feels like a long time too, so it looks like not only do we have a memory problem, we also have a performance problem.

Back to the drawing board we go.

<Callout label="How much space DO we need?">

I got curious - assuming the JS heap is infinitely large, how much space do we need to store all the fish? Thankfully, the question is kind enough to provide us the expected answer for the example input, so we can figure it out with a bit of math.

With a starting school size of **five fish**, after **256 days**, there will be 26,984,457,539 fish in the school - almost 27 billion! If each fish is represented as a number, and each [number takes up eight bytes of memory](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number), then we will need almost 216 **gigabytes** of memory to store all the fish!

</Callout>

### A Smarter Solution

I was staring at the code for a while trying to think of ways to optimize it, and I figured there's two things we can change:

1. Remove the array altogether. The question asked for the _number_ of fish, not the values of them, so it would be wasteful to store the array.
2. Removing the outer `days` loop. Is there a way for us to _infer_ the final value without having to loop through every single day?

## inferring the final value

this is entirely because the fish’s value loops every 7 days. let me explain with an example. lets say we start with the value 1 and we want to know what value the fish will be after 3 days.

every day, we decrement the value of the fish, so my first thought was to subtract the starting value with the number of days. in this case, we get `1 - 3 = -2`. of course, -2 isn’t a valid value for a fish, so we have to convert it to a valid value somehow.

a fish is only valid in the range `[0,6]`, inclusive (meaning both 0 and 6 are valid values). when a fish is at 0, decrementing it will circle back to the top of the range, 6 in this case:

```
day 0 -> 1
day 1 -> 0
day 2 -> 6
day 3 -> 5
```

so how do we convert -2 to 5? by adding 7, the length of the cycle!

ok, but what if it loops again? let’s say, in day 9?

```
day 0 -> 1
day 1 -> 0
day 2 -> 6
day 3 -> 5
day 4 -> 4
day 5 -> 3
day 6 -> 2
day 7 -> 1
day 8 -> 0
day 9 -> 6
```

if we subtract 9 from the start value, we get `1 - 9 = -8`. if we add 7 to this, we get -1, still not a valid value! to get the right value, 6, we need to add 7 again. so what we actually want is to add 7 times the number of cycles so far. this is a bit tedious so thankfully we can just use the `mod` operator to get the negative value that we're looking for: `-8 mod 7` gives us -1, and we add 7, giving us 6, the final value we're looking for. to summarize, the value of a fish after x days is: `((start value - x) mod 7) + 7`

## finding the number of created fish

cool, so this gives us the value of the fish after x days, but what about all the fishes that it creates and their values?

every time the fish starts a new cycle, a new fish is created. in the above case, a fish is created on day 2 and day 9, when the fish resets back to 6:

```
day 0 -> 1
day 1 -> 0, 8
day 2 -> 6, 7
day 3 -> 5, 6
day 4 -> 4, 5
day 5 -> 3, 4
day 6 -> 2, 3
day 7 -> 1, 2
day 8 -> 0, 1, 8
day 9 -> 6, 0, 7
```

to get the number of new fish a fish created, we have to determine the number of cycles. one way to do this is to subtract the number of days by the starting value, then dividing by 7.

we subtract the starting value from the number of days because the first cycle begins when the fish goes down to zero for the first time, which happens after `start value` days has passed.

```
day 0 -> 1
day 1 -> 0 <-- cycle 1 begins
day 2 -> 6
day 3 -> 5
day 4 -> 4
day 5 -> 3
day 6 -> 2
day 7 -> 1
day 8 -> 0 <-- cycle 2 begins
day 9 -> 6
```

here, we have 9 days and the fish starts with a value of 1. using the formula, we get `(9 - 1) / 7 = 1.14`. the decimal value means we're part ways through the second cycle, but it means we already created the second fish. so it means we need to round the result into the _next_ highest integer, or 2 in this case. we can do that using the javascript `math.ceil()` function:

```js
const fishCreated = (days, start) => Math.ceil((days - start) / 7)
```

## getting the fishes' fishes

good stuff, given a starting value and a number of days, we can now calculate:

- the number of fishes that fish creates
- the ending value of the fish after the given days have passed

but what about all the fishes that your fishes create? to get an accurate count of all the fishes at the end of the day, we need to add up all the fishes that the original fish created, but also all the fish that _those_ fish created, and so on.

thankfully, we already have the formula for determining the number of fish created after a certain number of days, so we can reuse that formula for all the fish that we created. except - what should the number of days be?

we can't reuse the same number of days because the fish didn't exist at the beginning. to get an accurate number, we need to somehow get the day when this fish was created, and subtract this value from the total number of days.

```
day 0 -> 1 <-- we use 9 days here because it existed from the start
day 1 -> 0
day 2 -> 6, 8 <-- this fish uses _8_ days instead day 9 is 8 days
                   _away_ from when this fish was created
day 3 -> 5, 7
day 4 -> 4, 6
day 5 -> 3, 5
day 6 -> 2, 4
day 7 -> 1, 3
day 8 -> 0, 2
day 9 -> 6, 1, 8 <-- this fish uses 0 days because day 9 is 0 days
away from when this fish was created
```

```js
const getTotalFishes = (start, days) => {
  const directFishesCreated = Math.max(Math.ceil(days - start / 7), 0)

  let subFishes = 0
  for (let fish = 0; fish < directFishesCreated; fish++) {
    subFishes += getTotalFishes(8 /* relative num of days */)
  }

  return 1 + subFishes
}
```

## getting a fish's birthday

so how do we get the relative number of days for each fish? to calculate this, we need to find the day a fish was created.

we know that a fish is created once a cycle and a cycle lasts for 7 days. let's say we start with a fish of value 6, meaning the fish _just_ restarted its cycle, and we go on for 7 days. when do we expect the new fish to be created?

```
day 0 -> 6
day 1 -> 5
day 2 -> 4
day 3 -> 3
day 4 -> 2
day 5 -> 1
day 6 -> 0
day 7 -> 6, 8
```

on day 7, exactly the length of the cycle! if we go on for another 7 days, we expect another fish to be created in day 14. so a fish is created every 7 days, which lets us infer a formula for the day a fish is born to be:

```
dayFishCreated = 7 * cycleNumber
```

where the cycle number ranges from 0 to however many cycles there are (which, equivalently, is also the number of fish that was created).

this is an ok start, but it really only works because we started with a fish value of 6, the top of the cycle. what if the starting value is something else?

if we start with a value of 1 like in our previous examples, the first fish will be born on _day 2_, not day 7:

```
day 0 -> 1
day 1 -> 0
day 2 -> 6, 8 <-- fish was born
day 3 -> 5, 7
```

but afterwards, a new fish is created every 7 days, so the next one will be in day 9:

```
day 0 -> 1
day 1 -> 0
day 2 -> 6, 8 <-- fish #1
day 3 -> 5, 7,
day 4 -> 4, 6
day 5 -> 3, 5
day 6 -> 2, 4
day 7 -> 1, 3
day 8 -> 0, 2
day 9 -> 6, 1, 8 <-- fish #2
```

this means that our cycle is shifted a little bit by whatever the starting value is, so our formula needs to take the starting value into account.

at the smallest possible value 0, a new fish will be born in day 1:

```
day 0 -> 0
day 1 -> 6, 8
```

increasing the starting value by 1 will push the first fish's birthdate back by 1 day:

```
day 0 -> 1
day 1 -> 0
day 2 -> 6, 8
```

so this means we need to add the starting value to `7 * cycleNumber` to get the first fish's birthdate:

```
dayFishCreated = start + 1 + (7 * cycleNumber)
```

note that cycleNumber starts at 0 because at the start, we haven't gone through a cycle just yet.

we also add 1 here because if the starting value is 0, the fish is created on _day 1_, not day 0.

## putting it together

ok, cool! now that we know the birthday of any given fish, we can get the _relative_ number of days till the end by subtracting the total number of days with the birthday:

```js
const birthday = start + 1 + 7 * cycleNumber
subFishes += getTotalFish(8, days - birthday)
```

once we have the counts of all the fishes, we return that count + 1 (the fish that we started with):

```js
const getTotalFishes = (start, days) => {
  const cycles = Math.max(Math.ceil(days - start / 7), 0)

  let subFishes = 0
  for (let cycleNumber = 0; cycleNumber < cycles; cycleNumber++) {
    const birthday = start + 1 + 7 * cycleNumber
    subFishes += getTotalFish(8, days - birthday)
  }

  return 1 + subFishes
}
```

we don't include cycles in the final count to prevent double counting - the recursive `getTotalFishes` call will already include the fish that we created in its total.

## performance testing

great! let's give this a shot and see how it fares compared to our other implementation.

first let's hook it up to the original function:

```jsx
const DAYS = 256

export default (...fishes) => {
  let total = 0

  fishes.forEach((start) => {
    total += getTotalFishes(start, DAYS)
  })

  return total
}
```

remember that the original implementation ran for 18s before crashing because it ran out of memory. how does this one perform in comparison?

uh, it didn't run out of memory at least?

## iteration counter

let's tone down the number of days a little bit and add some logs to see what's going on.

for my part a solution, i added an iterations counter and incremented it for each iteration of the loop to see how many iterations we need to get the final answer:

```js
export default (...fishes) => {
  let iterations = 0

  for (let i = 0; i < DAYS; i++) {
    for (const [index, fish] of fishes.entries()) {
      iterations++
      if (!fish) {
        fishes[index] = NEW_FISH_TIME
        fishes.push(NEW_FISH_TIME + NEW_FISH_DELAY + 1)
      } else {
        fishes[index]--
      }
    }
  }

  console.log({ iterations })

  return fishes.length
}
```

- running it against the example input (which starts with 5 fishes), the algorithm needed 70k iterations to complete.
- running it against the provided input (which starts with 300 fishes), the algorithm needed over 4.4 million (!) iterations.
- running both algorithms took about 0.13s.

i added something similar for part b where i increment a counter for every call to `getTotalFishes`. the results were pretty surprising:

- the example input with **5 fishes** needed 5934 recursive calls
- the provided input with **300 fishes** needed over 385k recursive calls
- both inputs took a combined 0.10s to complete.

an order of magnitude better than the initial input, but still not quite fast enough it seems!

let's bump up the number of days to 100 days:

- part a needed 25 million iterations, ~0.32s to complete
- part b needed 2.17 million calls, ~0.2s to complete

and again to 120 days:

- part a -> 145 million iterations, 1.36s
- part b -> 12 million iterations, 0.84s

so the part b solution is about an order of magnitude faster than part a, but it's still not fast enough to solve 256 days in a decent amount of time.

how can we make it better?

## adding a cache

one thing i noticed is that we're doing repetitive work when moving from one fish to the next. for example, let's say we start with the following fishes and we want to calculate the total number of fishes after 10 days:

```
3,1,3
```

using our algorithm, we calculate the total number of fish created by the first fish 3, then the second fish 1, and the third fish 3.

however, the result of the first fish and the last fish is going to be the same because the number of days is the same and the starting value is the same as well, i.e. for both of those fishes we call this function:

```js
totalFishes += getTotalFishes(3, 10)
```

when we're calling the function a second time, we're _repeating_ the work of calling the function the first time. we can potentially save this inefficiency by storing the result of the previous calculation, and referring to that result instead, a process called **memoization**.

the general idea is this:

1. we add an object that's going to act as a "cache" - this object will contain key-value pairs where the key is a combination of the starting fish value and number of days, and the value is the total fish created after those number of days have passed.
2. before we start the calculation, we first check if the cache contains the combination of fish value and number of days; if it does, we return it. otherwise, we continue on with the calculation.
3. once we've calculated the total number of fish, we add the fish value-number of days combination to the cache.

in code, that looks something like this:

```js
const DAYS = 120

const cache = {}

export default (...fishes) => {
  let fishCount = 0

  fishes.forEach((start) => {
    fishCount += getTotalFishes(start, DAYS)
  })

  return fishCount
}

const getTotalFishes = (start, days) => {
  const key = `${start}-${days}`

  /**
   * Look in the cache to see if we've calculated this
   * specific combination of start and days.
   */
  if (cache[key]) {
    return cache[key]
  }

  const fishesCreated = Math.max(Math.ceil((days - start) / 7), 0)

  let subFishes = 0

  for (let offset = 0; offset < fishesCreated; offset++) {
    const birthday = start + 1 + 7 * offset
    subFishes += getTotalFishes(8, days - birthday)
  }

  const fishes = 1 + subFishes
  // add our result to the cache so future calls can refer to it
  cache[key] = fishes

  return fishes
}
```

let's try it out. how much better is this approach?

on the left is the command _without_ the cache, and on the right _with_ the cache, both calculating 120 days:

// gif showing side by side comparison

whoa! 0.84s down to 0.07s.

what if we bump it up to 140 days? or even higher?

// slider to change number of days

it'll take too long to show here, but the original approach took about 25 seconds to calculate 160 days whereas the cached approach took 0.07s - basically the same amount of time as before.

// graph with the time

as we keep adding days, the time it takes for the uncached approach explodes until it times out - but the cached approach takes almost the same amount of time every time, regardless of how many days there are. you can't even see the line in the graph above!

i bumped up the number of days to an absurd number like 1000 days and the cached approach took only _0.01s longer to complete_. my computer would light on fire if i tried running 1000 days on the original, uncached approach.

## analysis

so what gives? how come adding a cache makes the algorithm that much faster? to look into this, i added some more counters to count the number of times that a cache _hit_ and a cache _miss_ occurs.

- a cache hit is when the cache contains the arguments we're looking for, so we can skip the computation
- a cache miss is when the cache _doesn't_ contain the arguments we're looking for, so we need to manually perform the computation

```jsx
const DAYS = 120

const cache = {}
let hits = 0
let misses = 0

export default (...fishes) => {
  let fishCount = 0

  fishes.forEach((start) => {
    fishCount += getTotalFishes(start, DAYS)
  })

  console.log({ hits, misses })

  return fishCount
}

const getTotalFishes = (start, days) => {
  const key = `${start}-${days}`

  /**
   * Look in the cache to see if we've calculated this
   * specific combination of start and days.
   */
  if (cache[key]) {
    hits++
    return cache[key]
  }

  misses++

  const fishesCreated = Math.max(Math.ceil((days - start) / 7), 0)

  let subFishes = 0

  for (let offset = 0; offset < fishesCreated; offset++) {
    const birthday = start + 1 + 7 * offset
    subFishes += getTotalFishes(8, days - birthday)
  }

  const fishes = 1 + subFishes
  cache[key] = fishes

  return fishes
}
```

without the cache, computing 120 days took about ~12 million calls to `getTotalFishes`. what about with the cache?

```
$ yarn test 6b
  { hits: 1158, misses: 122 }
  Result: 11967638
  Done in 0.07s.
```

adding up the number of hits and misses gives us the total number of calls to be 1280 calls - about 10,000x less calls than without the cache! this means that >99% of the calls were part of repeated work that we got rid of using the cache.

out of those 1280 calls, 1158 were cache hits, meaning 90.4% of the time, the cache contained the answer we were looking for. this also means that we only needed to run 10% of the calls to get the answer for 100% of the input.

in a larger number of days, the effect is even more pronounced. with 1200 days, 101k out of 102k total calls were cache hits - 99% of the calculations were repeats!

## summary

here's my solution to advent of code's day 6 problem in its entirety, without the performance measuring code:

```js
const DAYS = 256

const cache = {}

export default (...fishes) => {
  let fishCount = 0

  fishes.forEach((start) => {
    fishCount += getTotalFishes(start, DAYS)
  })

  return fishCount
}

const getTotalFishes = (start, days) => {
  const key = `${start}-${days}`

  /**
   * Look in the cache to see if we've calculated this
   * specific combination of start and days.
   */
  if (cache[key]) {
    return cache[key]
  }

  const fishesCreated = Math.max(Math.ceil((days - start) / 7), 0)

  let subFishes = 0

  for (let offset = 0; offset < fishesCreated; offset++) {
    const birthday = start + 1 + 7 * offset
    subFishes += getTotalFishes(8, days - birthday)
  }

  const fishes = 1 + subFishes
  cache[key] = fishes

  return fishes
}
```

i'm pretty proud of this one because i'm not quite good with algorithms, and i figured this out all on my own! i admit, when i added the cache, i didn't think it would improve the solution by as much as it did, but i'm glad it worked out.

i came across a few other clever solutions out there (like one involving rotating arrays) that i'm not quite clever enough to decipher, but this approach was the one that made the most sense to me. maybe i'll amend this post in the future with those solutions when (or if) i figure it out.

until next time, thanks for reading!
